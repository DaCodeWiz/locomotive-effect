{"version":3,"file":"src_containers_Home_tsx.js","mappings":";;;;;;;;;;;;;;;;;;;AAA6E;AACpB;AACD;;AAExD;AACA,8CAA8C,SAAS,6DAAe,aAAa,+DAAiB,UAAU,4DAAc,aAAa,+DAAiB,WAAW,6DAAe,kCAAkC,IAAI;AAC1N;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,YAAY,mEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qEAAW,oBAAoB,8DAAY;AACzE,yBAAyB,kEAAiB;AAC1C,cAAc,sEAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;;;;;;;;ACnJkC;AACW;;AAElE;AACA,UAAU,8DAAW;AACrB,eAAe,8DAAW;AAC1B,mBAAmB,8DAAW;AAC9B,gBAAgB,8DAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wDAAK;AACxB;AACA;AACA,WAAW,wDAAU;AACrB;AACA;AACA,WAAW,8DAAY;AACvB,iBAAiB,sDAAI;AACrB;AACA;;AAEkD;;;;;;;;;;;;;;;;;;;;;ACpCsC;AACnC;;AAErD;AACA,qCAAqC,+DAAa,0BAA0B,wDAAU;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAU;AAC/B;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA,4CAA4C,0DAAQ;AACpD,8BAA8B,kEAAmB;AACjD;AACA,eAAe,qDAAG;AAClB;AACA;;AAEuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3ByC;AACM;AACrB;AACkD;AACC;AAC/C;AACM;AACe;AACpC;AACsB;AACC;;AAE7D;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA,UAAU,WAAW,+DAAiB,UAAU,4DAAc,aAAa,+DAAiB,WAAW,6DAAe,WAAW,6DAAe,wDAAwD;AACxM,iBAAiB,6DAAgB;AACjC,6BAA6B,0EAAc;AAC3C,6BAA6B,oEAAW;AACxC;AACA;AACA;AACA;AACA,wBAAwB,8EAAqB;AAC7C,iBAAiB,yEAAY;AAC7B,wBAAwB,2DAAc;AACtC;AACA;AACA;AACA;AACA,uBAAuB,6EAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0EAAa,0BAA0B,mEAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA,yCAAyC,YAAY,mBAAmB,mDAAS;AACjF;AACA;AACA;AACA;AACA,wBAAwB,wEAAgB,CAAC,qEAAa;AACtD,YAAY,mEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAQ;AACpB,gBAAgB,wFAA4B;AAC5C,gBAAgB,yEAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,0DAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA,gDAAgD,qFAAyB;AACzE;AACA;AACA;AACA;AACA,uBAAuB,sDAAO;AAC9B,0BAA0B,sDAAO;AACjC,0BAA0B,sDAAO;AACjC,yBAAyB,8DAAY,WAAW,mEAAa;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8DAAY,sBAAsB,+DAAa;AACvE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,mDAAS;AACzB;AACA;AACA,aAAa;AACb,uBAAuB,mDAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,sDAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mDAAS;AACzB;AACA,4BAA4B,4DAAS,kDAAkD,cAAc;AACrG,wBAAwB;AACxB;AACA;AACA;AACA,YAAY,mDAAS,8BAA8B,0DAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;;;;AClLuB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mCAAmC,yDAAW;AAC9C;AACA;AACA;;AAE4C;;;;;;;;;;;;;;;;;;;ACnBK;AACW;AACI;;AAEhE;AACA;AACA,eAAe,yEAAY;AAC3B,oBAAoB,8DAAQ;AAC5B;AACA;AACA;AACA,+BAA+B,6EAAwB;AACvD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,eAAe,yEAAY;AAC3B,YAAY,8DAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEiB;;;;;;;;;;;;;;;;;;;;;AC5BuC;AACD;;AAEvD;AACA,gEAAgE,+DAAiB;AACjF;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,kDAAI;AACnG;AACA;AACA;AACA,sEAAsE,oEAAa;AACnF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,wBAAwB,qDAAO;AAC/B;AACA;AACA,gCAAgC,8BAA8B;AAC9D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAE+C;;;;;;;;;;;;;;;;;;;ACpDW;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB,EAAE,uEAAwB;AACjE,cAAc,uEAAwB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAE+D;;;;;;;;;;;;;;;;;;ACtBd;;AAEjD,kCAAkC,+DAAa;AAC/C,8DAA8D,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE;;AAEpC;;;;;;;;;;;;;;;;ACL9C,wFAAwF,iBAAiB;AACzG;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,4CAA4C,iBAAiB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoB;;;;;;;;;;;;;;;;;AC1BgE;;AAEpF;AACA,QAAQ,6DAAc;AACtB,cAAc,6DAAc;AAC5B,WAAW,8DAAW,QAAQ,oEAAiB;AAC/C;;AAEwB;;;;;;;;;;;;;;;;;ACRxB;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2C;;;;;;;;;;;;;;;;ACV3C;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,4CAA4C;;AAEnE;;;;;;;;;;;;;;;;ACRtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;;ACjB3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;;;;;;;;;;;;AChBoC;AACZ;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,uBAAuB,wDAAU;AACjC,KAAK;AACL;AACA;AACA;AACA,gDAAgD,KAAK;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa,EAAE,6DAAgB;AAC3C,IAAI,+DAAa;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,UAAU,EAAE,KAAK,OAAO,wBAAwB;;AAEuD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5E7H;AACQ;AAC6D;AAC7C;AACO;AACc;AACX;AACL;AACc;AACV;AACT;AACL;AACC;;AAEnD,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0EAAY;AACzC;AACA,WAAW,wFAAyB;AACpC;AACA;AACA;AACA,yDAAyD;AACzD,UAAU,sBAAsB,wBAAwB,6CAAM;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA,0BAA0B,oEAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sFAAe;AACxC;AACA,mCAAmC,4BAA4B;AAC/D;AACA;AACA;AACA;AACA,qCAAqC,6EAAa;AAClD,qCAAqC,wEAAU;AAC/C,sBAAsB,sCAAsC,+DAAiB,oCAAoC,6DAAe,IAAI;AACpI,oBAAoB,mEAAiB;AACrC,6CAA6C,6EAAW;AACxD,oBAAoB,qDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oEAAa;AAC3C;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS,gEAAa,0BAA0B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6DAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gEAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6DAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD,wBAAwB,oBAAoB;AAC5C;AACA,iCAAiC,2DAAQ;AACzC,2CAA2C,6DAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,qBAAqB,mEAAmE;AACpJ;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkD;;;;;;;;;;;;;;;;;ACrLN;;AAE5C;AACA;AACA,QAAQ,0DAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;;;;;;AClB2B;AACQ;;AAE3D;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA,YAAY,4DAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA,gBAAgB,qDAAG;AACnB,oBAAoB,yEAAmB;AACvC,SAAS;AACT;AACA;;AAEwC;;;;;;;;;;;;;;;;AC7BxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;;;;;;ACTmB;AACa;;AAEzD,mCAAmC,8BAA8B,IAAI;AACrE;AACA,0BAA0B,0DAAQ;AAClC;AACA;AACA;AACA;AACA,mCAAmC,uEAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgD;;;;;;;;;;;;;;;;;AC/BF;;AAE9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wDAAU;AACzB;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;;ACpDkB;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uDAAK;AAChB;;AAEiB;;;;;;;;;;;;;;;;ACZjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kIAAkI;AAClI;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;;AChBvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;;;;;;;;;;;;;;;;ACRrC;;AAEiB;;;;;;;;;;;;;;;;ACFjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoB;;;;;;;;;;;;;;;;;;;;ACRpB;AACA;AACA;AACA;AACA;AACA;;AAE8E;;;;;;;;;;;;;;;;ACP9E;;AAEe;;;;;;;;;;;;;;;;;ACFf;AACA;;AAE4B;;;;;;;;;;;;;;;;;;;ACHM;AACU;;AAE5C;AACA;AACA,oBAAoB,gBAAgB;AACpC,+BAA+B,yDAAQ;AACvC,oBAAoB,+CAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;;;;;;;;;;;;;;;;AChBrC;;AAEoB;;;;;;;;;;;;;;;;ACFpB;AACA;AACA;AACA;;AAEgB;;;;;;;;;;;;;;;;ACLhB;AACA;AACA;AACA;;AAEgB;;;;;;;;;;;ACLhB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO,KAAyB;AAChC;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,CAAC;;AAED;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;A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;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,WAAW;AACnB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,QAAQ;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,aAAa;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AG9UF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB,sCAAsC,kBAAkB;AACnF,0BAA0B;AAC1B;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACO;AACP;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,6DAA6D,cAAc;AAC3E;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACO;AACP,oCAAoC;AACpC;AACA;AACO;AACP;AACA;AACA;AACO;AACP,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACO;AACP,cAAc,6BAA6B,0BAA0B,cAAc,qBAAqB;AACxG,iBAAiB,oDAAoD,qEAAqE,cAAc;AACxJ,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,mCAAmC,SAAS;AAC5C,mCAAmC,WAAW,UAAU;AACxD,0CAA0C,cAAc;AACxD;AACA,8GAA8G,OAAO;AACrH,iFAAiF,iBAAiB;AAClG,yDAAyD,gBAAgB,QAAQ;AACjF,+CAA+C,gBAAgB,gBAAgB;AAC/E;AACA,kCAAkC;AAClC;AACA;AACA,UAAU,YAAY,aAAa,SAAS,UAAU;AACtD,oCAAoC,SAAS;AAC7C;AACA;AACA;AACO;AACP;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACO;AACP,6BAA6B,sBAAsB;AACnD;AACA;AACA;AACA;AACA;AACO;AACP,kDAAkD,QAAQ;AAC1D,yCAAyC,QAAQ;AACjD,yDAAyD,QAAQ;AACjE;AACA;AACA;AACA;AACO;AACP,6EAA6E,OAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA,iBAAiB,uFAAuF,cAAc;AACtH,uBAAuB,gCAAgC,qCAAqC,2CAA2C;AACvI,4BAA4B,MAAM,iBAAiB,YAAY;AAC/D,uBAAuB;AACvB,8BAA8B;AAC9B,6BAA6B;AAC7B,4BAA4B;AAC5B;AACA;AACO;AACP;AACA,iBAAiB,6CAA6C,UAAU,sDAAsD,cAAc;AAC5I,0BAA0B,6BAA6B,oBAAoB,gDAAgD,kBAAkB;AAC7I;AACA;AACO;AACP;AACA;AACA,2GAA2G,uFAAuF,cAAc;AAChN,uBAAuB,8BAA8B,gDAAgD,wDAAwD;AAC7J,6CAA6C,sCAAsC,UAAU,mBAAmB,IAAI;AACpH;AACA;AACO;AACP,iCAAiC,uCAAuC,YAAY,KAAK,OAAO;AAChG;AACA;AACA;AACA;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,6CAA6C;AAC7C;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA","sources":["webpack://gatsby-starter-hello-world/./node_modules/@motionone/animation/dist/Animation.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/animation/dist/utils/easing.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/animation/dist/utils/interpolate.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/dom/dist/animate/animate-style.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/dom/dist/animate/data.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/dom/dist/animate/style.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/dom/dist/animate/utils/controls.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/dom/dist/animate/utils/css-var.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/dom/dist/animate/utils/easing.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/dom/dist/animate/utils/feature-detection.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/dom/dist/animate/utils/get-style-name.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/dom/dist/animate/utils/keyframes.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/dom/dist/animate/utils/options.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/dom/dist/animate/utils/resolve-elements.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/dom/dist/animate/utils/stop-animation.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/dom/dist/animate/utils/transforms.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/dom/dist/timeline/index.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/dom/dist/timeline/utils/calc-time.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/dom/dist/timeline/utils/edit.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/dom/dist/timeline/utils/sort.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/dom/dist/utils/stagger.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/easing/dist/cubic-bezier.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/easing/dist/steps.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/types/dist/MotionValue.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/utils/dist/array.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/utils/dist/clamp.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/utils/dist/defaults.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/utils/dist/is.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/utils/dist/mix.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/utils/dist/noop.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/utils/dist/offset.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/utils/dist/progress.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/utils/dist/time.es.js","webpack://gatsby-starter-hello-world/./node_modules/@motionone/utils/dist/wrap.es.js","webpack://gatsby-starter-hello-world/./node_modules/ev-emitter/ev-emitter.js","webpack://gatsby-starter-hello-world/./src/containers/Home.tsx","webpack://gatsby-starter-hello-world/./src/hooks/useLocomotiveScroll.ts","webpack://gatsby-starter-hello-world/./node_modules/hey-listen/dist/hey-listen.es.js","webpack://gatsby-starter-hello-world/./node_modules/imagesloaded/imagesloaded.js","webpack://gatsby-starter-hello-world/./node_modules/locomotive-scroll/src/locomotive-scroll.scss","webpack://gatsby-starter-hello-world/./node_modules/locomotive-scroll/dist/locomotive-scroll.esm.js","webpack://gatsby-starter-hello-world/./node_modules/tslib/tslib.es6.js"],"sourcesContent":["import { defaults, isEasingGenerator, isEasingList } from '@motionone/utils';\nimport { getEasingFunction } from './utils/easing.es.js';\nimport { interpolate } from './utils/interpolate.es.js';\n\nclass Animation {\n    constructor(output, keyframes = [0, 1], { easing = defaults.easing, duration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, offset, direction = \"normal\", } = {}) {\n        this.startTime = null;\n        this.rate = 1;\n        this.t = 0;\n        this.cancelTimestamp = null;\n        this.playState = \"idle\";\n        this.finished = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n        if (isEasingGenerator(easing)) {\n            const custom = easing.createAnimation(keyframes, () => \"0\", true);\n            easing = custom.easing;\n            if (custom.keyframes !== undefined)\n                keyframes = custom.keyframes;\n            if (custom.duration !== undefined)\n                duration = custom.duration;\n        }\n        const totalDuration = duration * (repeat + 1);\n        const interpolate$1 = interpolate(keyframes, offset, isEasingList(easing)\n            ? easing.map(getEasingFunction)\n            : getEasingFunction(easing));\n        this.tick = (timestamp) => {\n            var _a;\n            if (this.pauseTime)\n                timestamp = this.pauseTime;\n            let t = (timestamp - this.startTime) * this.rate;\n            this.t = t;\n            // Convert to seconds\n            t /= 1000;\n            // Rebase on delay\n            t = Math.max(t - delay, 0);\n            /**\n             * If this animation has finished, set the current time\n             * to the total duration.\n             */\n            if (this.playState === \"finished\")\n                t = totalDuration;\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = t / duration;\n            // TODO progress += iterationStart\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            iterationProgress === 1 && currentIteration--;\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const iterationIsOdd = currentIteration % 2;\n            if (direction === \"reverse\" ||\n                (direction === \"alternate\" && iterationIsOdd) ||\n                (direction === \"alternate-reverse\" && !iterationIsOdd)) {\n                iterationProgress = 1 - iterationProgress;\n            }\n            const latest = interpolate$1(t >= totalDuration ? 1 : Math.min(iterationProgress, 1));\n            output(latest);\n            const isAnimationFinished = this.playState === \"finished\" || t >= totalDuration + endDelay;\n            if (isAnimationFinished) {\n                this.playState = \"finished\";\n                (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, latest);\n            }\n            else if (this.playState !== \"idle\") {\n                this.frameRequestId = requestAnimationFrame(this.tick);\n            }\n        };\n        this.play();\n    }\n    play() {\n        var _a;\n        const now = performance.now();\n        this.playState = \"running\";\n        if (this.pauseTime) {\n            this.startTime = now - (this.pauseTime - ((_a = this.startTime) !== null && _a !== void 0 ? _a : 0));\n        }\n        else if (!this.startTime) {\n            this.startTime = now;\n        }\n        this.cancelTimestamp = this.startTime;\n        this.pauseTime = undefined;\n        requestAnimationFrame(this.tick);\n    }\n    pause() {\n        this.playState = \"paused\";\n        this.pauseTime = performance.now();\n    }\n    finish() {\n        this.playState = \"finished\";\n        this.tick(0);\n    }\n    stop() {\n        var _a;\n        this.playState = \"idle\";\n        if (this.frameRequestId !== undefined) {\n            cancelAnimationFrame(this.frameRequestId);\n        }\n        (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, false);\n    }\n    cancel() {\n        this.stop();\n        this.tick(this.cancelTimestamp);\n    }\n    reverse() {\n        this.rate *= -1;\n    }\n    commitStyles() { }\n    get currentTime() {\n        return this.t;\n    }\n    set currentTime(t) {\n        if (this.pauseTime || this.rate === 0) {\n            this.pauseTime = t;\n        }\n        else {\n            this.startTime = performance.now() - t / this.rate;\n        }\n    }\n    get playbackRate() {\n        return this.rate;\n    }\n    set playbackRate(rate) {\n        this.rate = rate;\n    }\n}\n\nexport { Animation };\n","import { cubicBezier, steps } from '@motionone/easing';\nimport { noopReturn, isEasingList, wrap } from '@motionone/utils';\n\nconst namedEasings = {\n    ease: cubicBezier(0.25, 0.1, 0.25, 1.0),\n    \"ease-in\": cubicBezier(0.42, 0.0, 1.0, 1.0),\n    \"ease-in-out\": cubicBezier(0.42, 0.0, 0.58, 1.0),\n    \"ease-out\": cubicBezier(0.0, 0.0, 0.58, 1.0),\n};\nconst functionArgsRegex = /\\((.*?)\\)/;\nfunction getEasingFunction(definition) {\n    // If already an easing function, return\n    if (typeof definition === \"function\")\n        return definition;\n    // If an easing curve definition, return bezier function\n    if (Array.isArray(definition))\n        return cubicBezier(...definition);\n    // If we have a predefined easing function, return\n    if (namedEasings[definition])\n        return namedEasings[definition];\n    // If this is a steps function, attempt to create easing curve\n    if (definition.startsWith(\"steps\")) {\n        const args = functionArgsRegex.exec(definition);\n        if (args) {\n            const argsArray = args[1].split(\",\");\n            return steps(parseFloat(argsArray[0]), argsArray[1].trim());\n        }\n    }\n    return noopReturn;\n}\nfunction getEasingForSegment(easing, i) {\n    return isEasingList(easing)\n        ? easing[wrap(0, easing.length, i)]\n        : easing;\n}\n\nexport { getEasingForSegment, getEasingFunction };\n","import { progress, mix, defaultOffset, noopReturn, fillOffset } from '@motionone/utils';\nimport { getEasingForSegment } from './easing.es.js';\n\nconst clampProgress = (p) => Math.min(1, Math.max(p, 0));\nfunction interpolate(output, input = defaultOffset(output.length), easing = noopReturn) {\n    const length = output.length;\n    /**\n     * If the input length is lower than the output we\n     * fill the input to match. This currently assumes the input\n     * is an animation progress value so is a good candidate for\n     * moving outside the function.\n     */\n    const remainder = length - input.length;\n    remainder > 0 && fillOffset(input, remainder);\n    return (t) => {\n        let i = 0;\n        for (; i < length - 2; i++) {\n            if (t < input[i + 1])\n                break;\n        }\n        let progressInRange = clampProgress(progress(input[i], input[i + 1], t));\n        const segmentEasing = getEasingForSegment(easing, i);\n        progressInRange = segmentEasing(progressInRange);\n        return mix(output[i], output[i + 1], progressInRange);\n    };\n}\n\nexport { interpolate };\n","import { getAnimationData, getMotionValue } from './data.es.js';\nimport { isCssVar, registerCssVariable } from './utils/css-var.es.js';\nimport { Animation } from '@motionone/animation';\nimport { defaults, isEasingGenerator, isNumber, time, isEasingList, noop } from '@motionone/utils';\nimport { isTransform, addTransformToElement, transformDefinitions } from './utils/transforms.es.js';\nimport { convertEasing } from './utils/easing.es.js';\nimport { supports } from './utils/feature-detection.es.js';\nimport { hydrateKeyframes, keyframesList } from './utils/keyframes.es.js';\nimport { style } from './style.es.js';\nimport { getStyleName } from './utils/get-style-name.es.js';\nimport { stopAnimation } from './utils/stop-animation.es.js';\n\nfunction getDevToolsRecord() {\n    return window.__MOTION_DEV_TOOLS_RECORD;\n}\nfunction animateStyle(element, key, keyframesDefinition, options = {}) {\n    const record = getDevToolsRecord();\n    const isRecording = options.record !== false && record;\n    let animation;\n    let { duration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, easing = defaults.easing, direction, offset, allowWebkitAcceleration = false, } = options;\n    const data = getAnimationData(element);\n    let canAnimateNatively = supports.waapi();\n    const valueIsTransform = isTransform(key);\n    /**\n     * If this is an individual transform, we need to map its\n     * key to a CSS variable and update the element's transform style\n     */\n    valueIsTransform && addTransformToElement(element, key);\n    const name = getStyleName(key);\n    const motionValue = getMotionValue(data.values, name);\n    /**\n     * Get definition of value, this will be used to convert numerical\n     * keyframes into the default value type.\n     */\n    const definition = transformDefinitions.get(name);\n    /**\n     * Stop the current animation, if any. Because this will trigger\n     * commitStyles (DOM writes) and we might later trigger DOM reads,\n     * this is fired now and we return a factory function to create\n     * the actual animation that can get called in batch,\n     */\n    stopAnimation(motionValue.animation, !(isEasingGenerator(easing) && motionValue.generator) &&\n        options.record !== false);\n    /**\n     * Batchable factory function containing all DOM reads.\n     */\n    return () => {\n        const readInitialValue = () => { var _a, _b; return (_b = (_a = style.get(element, name)) !== null && _a !== void 0 ? _a : definition === null || definition === void 0 ? void 0 : definition.initialValue) !== null && _b !== void 0 ? _b : 0; };\n        /**\n         * Replace null values with the previous keyframe value, or read\n         * it from the DOM if it's the first keyframe.\n         */\n        let keyframes = hydrateKeyframes(keyframesList(keyframesDefinition), readInitialValue);\n        if (isEasingGenerator(easing)) {\n            const custom = easing.createAnimation(keyframes, readInitialValue, valueIsTransform, name, motionValue);\n            easing = custom.easing;\n            if (custom.keyframes !== undefined)\n                keyframes = custom.keyframes;\n            if (custom.duration !== undefined)\n                duration = custom.duration;\n        }\n        /**\n         * If this is a CSS variable we need to register it with the browser\n         * before it can be animated natively. We also set it with setProperty\n         * rather than directly onto the element.style object.\n         */\n        if (isCssVar(name)) {\n            if (supports.cssRegisterProperty()) {\n                registerCssVariable(name);\n            }\n            else {\n                canAnimateNatively = false;\n            }\n        }\n        /**\n         * If we can animate this value with WAAPI, do so. Currently this only\n         * feature detects CSS.registerProperty but could check WAAPI too.\n         */\n        if (canAnimateNatively) {\n            /**\n             * Convert numbers to default value types. Currently this only supports\n             * transforms but it could also support other value types.\n             */\n            if (definition) {\n                keyframes = keyframes.map((value) => isNumber(value) ? definition.toDefaultUnit(value) : value);\n            }\n            /**\n             * If this browser doesn't support partial/implicit keyframes we need to\n             * explicitly provide one.\n             */\n            const needsToReadInitialKeyframe = !supports.partialKeyframes() && keyframes.length === 1;\n            if (isRecording || needsToReadInitialKeyframe) {\n                keyframes.unshift(readInitialValue());\n            }\n            const animationOptions = {\n                delay: time.ms(delay),\n                duration: time.ms(duration),\n                endDelay: time.ms(endDelay),\n                easing: !isEasingList(easing) ? convertEasing(easing) : undefined,\n                direction,\n                iterations: repeat + 1,\n                fill: \"both\",\n            };\n            animation = element.animate({\n                [name]: keyframes,\n                offset,\n                easing: isEasingList(easing) ? easing.map(convertEasing) : undefined,\n            }, animationOptions);\n            /**\n             * Polyfill finished Promise in browsers that don't support it\n             */\n            if (!animation.finished) {\n                animation.finished = new Promise((resolve, reject) => {\n                    animation.onfinish = resolve;\n                    animation.oncancel = reject;\n                });\n            }\n            const target = keyframes[keyframes.length - 1];\n            animation.finished\n                .then(() => {\n                // Apply styles to target\n                style.set(element, name, target);\n                // Ensure fill modes don't persist\n                animation.cancel();\n            })\n                .catch(noop);\n            /**\n             * This forces Webkit to run animations on the main thread by exploiting\n             * this condition:\n             * https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/platform/graphics/ca/GraphicsLayerCA.cpp?rev=281238#L1099\n             *\n             * This fixes Webkit's timing bugs, like accelerated animations falling\n             * out of sync with main thread animations and massive delays in starting\n             * accelerated animations in WKWebView.\n             */\n            if (!allowWebkitAcceleration)\n                animation.playbackRate = 1.000001;\n            /**\n             * If we can't animate the value natively then we can fallback to the numbers-only\n             * polyfill for transforms. All keyframes must be numerical.\n             */\n        }\n        else if (valueIsTransform && keyframes.every(isNumber)) {\n            /**\n             * If we only have a single keyframe, we need to create an initial keyframe by reading\n             * the current value from the DOM.\n             */\n            if (keyframes.length === 1) {\n                keyframes.unshift(parseFloat(readInitialValue()));\n            }\n            const render = (latest) => {\n                if (definition)\n                    latest = definition.toDefaultUnit(latest);\n                style.set(element, name, latest);\n            };\n            animation = new Animation(render, keyframes, Object.assign(Object.assign({}, options), { duration,\n                easing }));\n        }\n        else {\n            const target = keyframes[keyframes.length - 1];\n            style.set(element, name, definition && isNumber(target)\n                ? definition.toDefaultUnit(target)\n                : target);\n        }\n        if (isRecording) {\n            record(element, key, keyframes, {\n                duration,\n                delay,\n                easing,\n                repeat,\n                offset,\n            }, \"motion-one\");\n        }\n        motionValue.setAnimation(animation);\n        return animation;\n    };\n}\n\nexport { animateStyle };\n","import { MotionValue } from '@motionone/types';\n\nconst data = new WeakMap();\nfunction getAnimationData(element) {\n    if (!data.has(element)) {\n        data.set(element, {\n            transforms: [],\n            values: new Map(),\n        });\n    }\n    return data.get(element);\n}\nfunction getMotionValue(motionValues, name) {\n    if (!motionValues.has(name)) {\n        motionValues.set(name, new MotionValue());\n    }\n    return motionValues.get(name);\n}\n\nexport { getAnimationData, getMotionValue };\n","import { isCssVar } from './utils/css-var.es.js';\nimport { getStyleName } from './utils/get-style-name.es.js';\nimport { transformDefinitions } from './utils/transforms.es.js';\n\nconst style = {\n    get: (element, name) => {\n        name = getStyleName(name);\n        let value = isCssVar(name)\n            ? element.style.getPropertyValue(name)\n            : getComputedStyle(element)[name];\n        if (!value && value !== 0) {\n            const definition = transformDefinitions.get(name);\n            if (definition)\n                value = definition.initialValue;\n        }\n        return value;\n    },\n    set: (element, name, value) => {\n        name = getStyleName(name);\n        if (isCssVar(name)) {\n            element.style.setProperty(name, value);\n        }\n        else {\n            element.style[name] = value;\n        }\n    },\n};\n\nexport { style };\n","import { defaults, noop, time } from '@motionone/utils';\nimport { stopAnimation } from './stop-animation.es.js';\n\nconst createAnimation = (factory) => factory();\nconst wrapAnimationWithControls = (animationFactory, duration = defaults.duration) => new Proxy({\n    animations: animationFactory.map(createAnimation).filter(Boolean),\n    duration,\n}, controls);\n/**\n * TODO:\n * Currently this returns the first animation, ideally it would return\n * the first active animation.\n */\nconst getActiveAnimation = (state) => state.animations[0];\nconst controls = {\n    get: (target, key) => {\n        var _a, _b;\n        switch (key) {\n            case \"duration\":\n                return target.duration;\n            case \"currentTime\":\n                let time = ((_a = getActiveAnimation(target)) === null || _a === void 0 ? void 0 : _a[key]) || 0;\n                return time ? time / 1000 : 0;\n            case \"playbackRate\":\n                return (_b = getActiveAnimation(target)) === null || _b === void 0 ? void 0 : _b[key];\n            case \"finished\":\n                if (!target.finished) {\n                    target.finished = Promise.all(target.animations.map(selectFinished)).catch(noop);\n                }\n                return target.finished;\n            case \"stop\":\n                return () => target.animations.forEach((animation) => stopAnimation(animation));\n            default:\n                return () => target.animations.forEach((animation) => animation[key]());\n        }\n    },\n    set: (target, key, value) => {\n        switch (key) {\n            case \"currentTime\":\n                value = time.ms(value);\n            case \"currentTime\":\n            case \"playbackRate\":\n                for (let i = 0; i < target.animations.length; i++) {\n                    target.animations[i][key] = value;\n                }\n                return true;\n        }\n        return false;\n    },\n};\nconst selectFinished = (animation) => animation.finished;\n\nexport { controls, wrapAnimationWithControls };\n","import { transformDefinitions } from './transforms.es.js';\n\nconst isCssVar = (name) => name.startsWith(\"--\");\nconst registeredProperties = new Set();\nfunction registerCssVariable(name) {\n    if (registeredProperties.has(name))\n        return;\n    registeredProperties.add(name);\n    try {\n        const { syntax, initialValue } = transformDefinitions.has(name)\n            ? transformDefinitions.get(name)\n            : {};\n        CSS.registerProperty({\n            name,\n            inherits: false,\n            syntax,\n            initialValue,\n        });\n    }\n    catch (e) { }\n}\n\nexport { isCssVar, registerCssVariable, registeredProperties };\n","import { isCubicBezier } from '@motionone/utils';\n\nconst convertEasing = (easing) => isCubicBezier(easing) ? cubicBezierAsString(easing) : easing;\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\n\nexport { convertEasing, cubicBezierAsString };\n","const testAnimation = (keyframes) => document.createElement(\"div\").animate(keyframes, { duration: 0.001 });\nconst featureTests = {\n    cssRegisterProperty: () => typeof CSS !== \"undefined\" &&\n        Object.hasOwnProperty.call(CSS, \"registerProperty\"),\n    waapi: () => Object.hasOwnProperty.call(Element.prototype, \"animate\"),\n    partialKeyframes: () => {\n        try {\n            testAnimation({ opacity: [1] });\n        }\n        catch (e) {\n            return false;\n        }\n        return true;\n    },\n    finished: () => Boolean(testAnimation({ opacity: [0, 1] }).finished),\n};\nconst results = {};\nconst supports = {};\nfor (const key in featureTests) {\n    supports[key] = () => {\n        if (results[key] === undefined)\n            results[key] = featureTests[key]();\n        return results[key];\n    };\n}\n\nexport { supports };\n","import { isTransform, asTransformCssVar, transformAlias } from './transforms.es.js';\n\nfunction getStyleName(key) {\n    if (transformAlias[key])\n        key = transformAlias[key];\n    return isTransform(key) ? asTransformCssVar(key) : key;\n}\n\nexport { getStyleName };\n","function hydrateKeyframes(keyframes, readInitialValue) {\n    for (let i = 0; i < keyframes.length; i++) {\n        if (keyframes[i] === null) {\n            keyframes[i] = i ? keyframes[i - 1] : readInitialValue();\n        }\n    }\n    return keyframes;\n}\nconst keyframesList = (keyframes) => Array.isArray(keyframes) ? keyframes : [keyframes];\n\nexport { hydrateKeyframes, keyframesList };\n","const getOptions = (options, key) => \n/**\n * TODO: Make test for this\n * Always return a new object otherwise delay is overwritten by results of stagger\n * and this results in no stagger\n */\noptions[key] ? Object.assign(Object.assign({}, options), options[key]) : Object.assign({}, options);\n\nexport { getOptions };\n","function resolveElements(elements, selectorCache) {\n    var _a;\n    if (typeof elements === \"string\") {\n        if (selectorCache) {\n            (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = document.querySelectorAll(elements));\n            elements = selectorCache[elements];\n        }\n        else {\n            elements = document.querySelectorAll(elements);\n        }\n    }\n    else if (elements instanceof Element) {\n        elements = [elements];\n    }\n    return Array.from(elements);\n}\n\nexport { resolveElements };\n","function stopAnimation(animation, needsCommit = true) {\n    if (!animation || animation.playState === \"finished\")\n        return;\n    // Suppress error thrown by WAAPI\n    try {\n        if (animation.stop) {\n            animation.stop();\n        }\n        else {\n            needsCommit && animation.commitStyles();\n            animation.cancel();\n        }\n    }\n    catch (e) { }\n}\n\nexport { stopAnimation };\n","import { noopReturn, addUniqueItem } from '@motionone/utils';\nimport { getAnimationData } from '../data.es.js';\n\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */\nconst axes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */\nconst order = [\"translate\", \"scale\", \"rotate\", \"skew\"];\nconst transformAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n};\nconst rotation = {\n    syntax: \"<angle>\",\n    initialValue: \"0deg\",\n    toDefaultUnit: (v) => v + \"deg\",\n};\nconst baseTransformProperties = {\n    translate: {\n        syntax: \"<length-percentage>\",\n        initialValue: \"0px\",\n        toDefaultUnit: (v) => v + \"px\",\n    },\n    rotate: rotation,\n    scale: {\n        syntax: \"<number>\",\n        initialValue: 1,\n        toDefaultUnit: noopReturn,\n    },\n    skew: rotation,\n};\nconst transformDefinitions = new Map();\nconst asTransformCssVar = (name) => `--motion-${name}`;\n/**\n * Generate a list of every possible transform key\n */\nconst transforms = [\"x\", \"y\", \"z\"];\norder.forEach((name) => {\n    axes.forEach((axis) => {\n        transforms.push(name + axis);\n        transformDefinitions.set(asTransformCssVar(name + axis), baseTransformProperties[name]);\n    });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */\nconst compareTransformOrder = (a, b) => transforms.indexOf(a) - transforms.indexOf(b);\n/**\n * Provide a quick way to check if a string is the name of a transform\n */\nconst transformLookup = new Set(transforms);\nconst isTransform = (name) => transformLookup.has(name);\nconst addTransformToElement = (element, name) => {\n    // Map x to translateX etc\n    if (transformAlias[name])\n        name = transformAlias[name];\n    const { transforms } = getAnimationData(element);\n    addUniqueItem(transforms, name);\n    /**\n     * TODO: An optimisation here could be to cache the transform in element data\n     * and only update if this has changed.\n     */\n    element.style.transform = buildTransformTemplate(transforms);\n};\nconst buildTransformTemplate = (transforms) => transforms\n    .sort(compareTransformOrder)\n    .reduce(transformListToString, \"\")\n    .trim();\nconst transformListToString = (template, name) => `${template} ${name}(var(${asTransformCssVar(name)}))`;\n\nexport { addTransformToElement, asTransformCssVar, axes, buildTransformTemplate, compareTransformOrder, isTransform, transformAlias, transformDefinitions };\n","import { __rest } from 'tslib';\nimport { invariant } from 'hey-listen';\nimport { defaults, isEasingGenerator, defaultOffset, fillOffset, progress } from '@motionone/utils';\nimport { resolveOption } from '../utils/stagger.es.js';\nimport { animateStyle } from '../animate/animate-style.es.js';\nimport { wrapAnimationWithControls } from '../animate/utils/controls.es.js';\nimport { keyframesList } from '../animate/utils/keyframes.es.js';\nimport { getOptions } from '../animate/utils/options.es.js';\nimport { resolveElements } from '../animate/utils/resolve-elements.es.js';\nimport { isTransform } from '../animate/utils/transforms.es.js';\nimport { calcNextTime } from './utils/calc-time.es.js';\nimport { addKeyframes } from './utils/edit.es.js';\nimport { compareByTime } from './utils/sort.es.js';\n\nfunction timeline(definition, options = {}) {\n    var _a;\n    const animationDefinitions = createAnimationsFromTimeline(definition, options);\n    /**\n     * Create and start animations\n     */\n    const animationFactories = animationDefinitions\n        .map((definition) => animateStyle(...definition))\n        .filter(Boolean);\n    return wrapAnimationWithControls(animationFactories, \n    // Get the duration from the first animation definition\n    (_a = animationDefinitions[0]) === null || _a === void 0 ? void 0 : _a[3].duration);\n}\nfunction createAnimationsFromTimeline(definition, _a = {}) {\n    var { defaultOptions = {} } = _a, timelineOptions = __rest(_a, [\"defaultOptions\"]);\n    const animationDefinitions = [];\n    const elementSequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the definition array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < definition.length; i++) {\n        const [elementDefinition, keyframes, options = {}] = definition[i];\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (options.at !== undefined) {\n            currentTime = calcNextTime(currentTime, options.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        /**\n         * Find all the elements specified in the definition and parse value\n         * keyframes from their timeline definitions.\n         */\n        const elements = resolveElements(elementDefinition, elementCache);\n        const numElements = elements.length;\n        for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n            const element = elements[elementIndex];\n            const elementSequence = getElementSequence(element, elementSequences);\n            for (const key in keyframes) {\n                const valueSequence = getValueSequence(key, elementSequence);\n                let valueKeyframes = keyframesList(keyframes[key]);\n                const valueOptions = getOptions(options, key);\n                let { duration = defaultOptions.duration || defaults.duration, easing = defaultOptions.easing || defaults.easing, } = valueOptions;\n                if (isEasingGenerator(easing)) {\n                    const valueIsTransform = isTransform(key);\n                    invariant(valueKeyframes.length === 2 || !valueIsTransform, \"spring must be provided 2 keyframes within timeline\");\n                    const custom = easing.createAnimation(valueKeyframes, \n                    // TODO We currently only support explicit keyframes\n                    // so this doesn't currently read from the DOM\n                    () => \"0\", valueIsTransform);\n                    easing = custom.easing;\n                    if (custom.keyframes !== undefined)\n                        valueKeyframes = custom.keyframes;\n                    if (custom.duration !== undefined)\n                        duration = custom.duration;\n                }\n                const delay = resolveOption(options.delay, elementIndex, numElements) || 0;\n                const startTime = currentTime + delay;\n                const targetTime = startTime + duration;\n                /**\n                 *\n                 */\n                let { offset = defaultOffset(valueKeyframes.length) } = valueOptions;\n                /**\n                 * If there's only one offset of 0, fill in a second with length 1\n                 *\n                 * TODO: Ensure there's a test that covers this removal\n                 */\n                if (offset.length === 1 && offset[0] === 0) {\n                    offset[1] = 1;\n                }\n                /**\n                 * Fill out if offset if fewer offsets than keyframes\n                 */\n                const remainder = length - valueKeyframes.length;\n                remainder > 0 && fillOffset(offset, remainder);\n                /**\n                 * If only one value has been set, ie [1], push a null to the start of\n                 * the keyframe array. This will let us mark a keyframe at this point\n                 * that will later be hydrated with the previous value.\n                 */\n                valueKeyframes.length === 1 && valueKeyframes.unshift(null);\n                /**\n                 * Add keyframes, mapping offsets to absolute time.\n                 */\n                addKeyframes(valueSequence, valueKeyframes, easing, offset, startTime, targetTime);\n                maxDuration = Math.max(delay + duration, maxDuration);\n                totalDuration = Math.max(targetTime, totalDuration);\n            }\n        }\n        prevTime = currentTime;\n        currentTime += maxDuration;\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    elementSequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(progress(0, totalDuration, at));\n                valueEasing.push(easing || defaults.easing);\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(\"linear\");\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            animationDefinitions.push([\n                element,\n                key,\n                keyframes,\n                Object.assign(Object.assign(Object.assign({}, defaultOptions), { duration: totalDuration, easing: valueEasing, offset: valueOffset }), timelineOptions),\n            ]);\n        }\n    });\n    return animationDefinitions;\n}\nfunction getElementSequence(element, sequences) {\n    !sequences.has(element) && sequences.set(element, {});\n    return sequences.get(element);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\n\nexport { createAnimationsFromTimeline, timeline };\n","import { isNumber } from '@motionone/utils';\n\nfunction calcNextTime(current, next, prev, labels) {\n    var _a;\n    if (isNumber(next)) {\n        return next;\n    }\n    else if (next.startsWith(\"-\") || next.startsWith(\"+\")) {\n        return Math.max(0, current + parseFloat(next));\n    }\n    else if (next === \"<\") {\n        return prev;\n    }\n    else {\n        return (_a = labels.get(next)) !== null && _a !== void 0 ? _a : current;\n    }\n}\n\nexport { calcNextTime };\n","import { mix, removeItem } from '@motionone/utils';\nimport { getEasingForSegment } from '@motionone/animation';\n\nfunction eraseKeyframes(sequence, startTime, endTime) {\n    for (let i = 0; i < sequence.length; i++) {\n        const keyframe = sequence[i];\n        if (keyframe.at > startTime && keyframe.at < endTime) {\n            removeItem(sequence, keyframe);\n            // If we remove this item we have to push the pointer back one\n            i--;\n        }\n    }\n}\nfunction addKeyframes(sequence, keyframes, easing, offset, startTime, endTime) {\n    /**\n     * Erase every existing value between currentTime and targetTime,\n     * this will essentially splice this timeline into any currently\n     * defined ones.\n     */\n    eraseKeyframes(sequence, startTime, endTime);\n    for (let i = 0; i < keyframes.length; i++) {\n        sequence.push({\n            value: keyframes[i],\n            at: mix(startTime, endTime, offset[i]),\n            easing: getEasingForSegment(easing, i),\n        });\n    }\n}\n\nexport { addKeyframes, eraseKeyframes };\n","function compareByTime(a, b) {\n    if (a.at === b.at) {\n        return a.value === null ? 1 : -1;\n    }\n    else {\n        return a.at - b.at;\n    }\n}\n\nexport { compareByTime };\n","import { isNumber } from '@motionone/utils';\nimport { getEasingFunction } from '@motionone/animation';\n\nfunction stagger(duration = 0.1, { start = 0, from = 0, easing } = {}) {\n    return (i, total) => {\n        const fromIndex = isNumber(from) ? from : getFromIndex(from, total);\n        const distance = Math.abs(fromIndex - i);\n        let delay = duration * distance;\n        if (easing) {\n            const maxDelay = total * i;\n            const easingFunction = getEasingFunction(easing);\n            delay = easingFunction(delay / maxDelay) * maxDelay;\n        }\n        return start + delay;\n    };\n}\nfunction getFromIndex(from, total) {\n    if (from === \"first\") {\n        return 0;\n    }\n    else {\n        const lastIndex = total - 1;\n        return from === \"last\" ? lastIndex : lastIndex / 2;\n    }\n}\nfunction resolveOption(option, i, total) {\n    return typeof option === \"function\"\n        ? option(i, total)\n        : option;\n}\n\nexport { getFromIndex, resolveOption, stagger };\n","import { noopReturn } from '@motionone/utils';\n\n/*\n  Bezier function generator\n\n  This has been modified from Gatan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return noopReturn;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nexport { cubicBezier };\n","import { clamp } from '@motionone/utils';\n\nconst steps = (steps, direction = \"end\") => (progress) => {\n    progress =\n        direction === \"end\"\n            ? Math.min(progress, 0.999)\n            : Math.max(progress, 0.001);\n    const expanded = progress * steps;\n    const rounded = direction === \"end\" ? Math.floor(expanded) : Math.ceil(expanded);\n    return clamp(0, 1, rounded / steps);\n};\n\nexport { steps };\n","/**\n * The MotionValue tracks the state of a single animatable\n * value. Currently, updatedAt and current are unused. The\n * long term idea is to use this to minimise the number\n * of DOM reads, and to abstract the DOM interactions here.\n */\nclass MotionValue {\n    setAnimation(animation) {\n        this.animation = animation;\n        animation === null || animation === void 0 ? void 0 : animation.finished.then(() => this.clearAnimation()).catch(() => { });\n    }\n    clearAnimation() {\n        this.animation = this.generator = undefined;\n    }\n}\n\nexport { MotionValue };\n","function addUniqueItem(array, item) {\n    array.indexOf(item) === -1 && array.push(item);\n}\nfunction removeItem(arr, item) {\n    const index = arr.indexOf(item);\n    index > -1 && arr.splice(index, 1);\n}\n\nexport { addUniqueItem, removeItem };\n","const clamp = (min, max, v) => Math.min(Math.max(v, min), max);\n\nexport { clamp };\n","const defaults = {\n    duration: 0.3,\n    delay: 0,\n    endDelay: 0,\n    repeat: 0,\n    easing: \"ease\",\n};\n\nexport { defaults };\n","const isNumber = (value) => typeof value === \"number\";\nconst isString = (value) => typeof value === \"string\";\nconst isEasingGenerator = (easing) => typeof easing === \"object\" &&\n    Boolean(easing.createAnimation);\nconst isCubicBezier = (easing) => Array.isArray(easing) && isNumber(easing[0]);\nconst isEasingList = (easing) => Array.isArray(easing) && !isNumber(easing[0]);\n\nexport { isCubicBezier, isEasingGenerator, isEasingList, isNumber, isString };\n","const mix = (min, max, progress) => -progress * min + progress * max + min;\n\nexport { mix };\n","const noop = () => { };\nconst noopReturn = (v) => v;\n\nexport { noop, noopReturn };\n","import { mix } from './mix.es.js';\nimport { progress } from './progress.es.js';\n\nfunction fillOffset(offset, remaining) {\n    const min = offset[offset.length - 1];\n    for (let i = 1; i <= remaining; i++) {\n        const offsetProgress = progress(0, remaining, i);\n        offset.push(mix(min, 1, offsetProgress));\n    }\n}\nfunction defaultOffset(length) {\n    const offset = [0];\n    fillOffset(offset, length - 1);\n    return offset;\n}\n\nexport { defaultOffset, fillOffset };\n","const progress = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);\n\nexport { progress };\n","const time = {\n    ms: (seconds) => seconds * 1000,\n    s: (milliseconds) => milliseconds / 1000,\n};\n\nexport { time };\n","const wrap = (min, max, v) => {\n    const rangeSize = max - min;\n    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\n};\n\nexport { wrap };\n","/**\n * EvEmitter v2.1.1\n * Lil' event emitter\n * MIT License\n */\n\n( function( global, factory ) {\n  // universal module definition\n  if ( typeof module == 'object' && module.exports ) {\n    // CommonJS - Browserify, Webpack\n    module.exports = factory();\n  } else {\n    // Browser globals\n    global.EvEmitter = factory();\n  }\n\n}( typeof window != 'undefined' ? window : this, function() {\n\nfunction EvEmitter() {}\n\nlet proto = EvEmitter.prototype;\n\nproto.on = function( eventName, listener ) {\n  if ( !eventName || !listener ) return this;\n\n  // set events hash\n  let events = this._events = this._events || {};\n  // set listeners array\n  let listeners = events[ eventName ] = events[ eventName ] || [];\n  // only add once\n  if ( !listeners.includes( listener ) ) {\n    listeners.push( listener );\n  }\n\n  return this;\n};\n\nproto.once = function( eventName, listener ) {\n  if ( !eventName || !listener ) return this;\n\n  // add event\n  this.on( eventName, listener );\n  // set once flag\n  // set onceEvents hash\n  let onceEvents = this._onceEvents = this._onceEvents || {};\n  // set onceListeners object\n  let onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};\n  // set flag\n  onceListeners[ listener ] = true;\n\n  return this;\n};\n\nproto.off = function( eventName, listener ) {\n  let listeners = this._events && this._events[ eventName ];\n  if ( !listeners || !listeners.length ) return this;\n\n  let index = listeners.indexOf( listener );\n  if ( index != -1 ) {\n    listeners.splice( index, 1 );\n  }\n\n  return this;\n};\n\nproto.emitEvent = function( eventName, args ) {\n  let listeners = this._events && this._events[ eventName ];\n  if ( !listeners || !listeners.length ) return this;\n\n  // copy over to avoid interference if .off() in listener\n  listeners = listeners.slice( 0 );\n  args = args || [];\n  // once stuff\n  let onceListeners = this._onceEvents && this._onceEvents[ eventName ];\n\n  for ( let listener of listeners ) {\n    let isOnce = onceListeners && onceListeners[ listener ];\n    if ( isOnce ) {\n      // remove listener\n      // remove before trigger to prevent recursion\n      this.off( eventName, listener );\n      // unset once flag\n      delete onceListeners[ listener ];\n    }\n    // trigger listener\n    listener.apply( this, args );\n  }\n\n  return this;\n};\n\nproto.allOff = function() {\n  delete this._events;\n  delete this._onceEvents;\n  return this;\n};\n\nreturn EvEmitter;\n\n} ) );\n","import React, { useEffect, useRef } from 'react';\nimport LocomotiveScroll from \"locomotive-scroll\";\nimport \"locomotive-scroll/src/locomotive-scroll.scss\";\nimport { timeline, animate, stagger } from \"motion\";\nimport imagesLoaded from 'imagesloaded';\nimport \"../styles/home.scss\";\nimport { TimelineDefinition } from \"@motionone/dom/types/timeline/types\";\nimport useLocomotiveScroll from \"../hooks/useLocomotiveScroll\";\n\n\nconst preloadImages = (selector: string) => {\n  return new Promise((resolve) => {\n    imagesLoaded(\n      document.querySelectorAll(selector),\n      { background: true },\n      resolve\n    );\n  });\n};\n\nfunction getSectionHeight(element: HTMLUListElement) {\n  const { height } = element.getBoundingClientRect();\n  const { childElementCount } = element;\n  return height / childElementCount;\n}\nexport default function Home() {\n  const scrollRef = useRef<HTMLDivElement | null>(null);\n  const countRef = useRef<HTMLUListElement | null>(null);\n  const countRef2 = useRef<HTMLUListElement | null>(null);\n  const loaderRef = useRef<HTMLDivElement | null>(null);\n\n  const titleRef = useRef<HTMLHeadingElement | null>(null);\n  const imageRef = useRef<HTMLImageElement | null>(null);\n\n  const [locomotiveRef] = useLocomotiveScroll({\n    ref: scrollRef,\n    smooth: true,\n    smoothMobile: true,\n  });\n\n  useEffect(() => {\n    // Preload images\n    Promise.all([preloadImages(\".grid-item-media\")]).then(() => {\n      if (locomotiveRef.current) {\n        locomotiveRef.current.update();\n      }\n    });\n  }, []);\n\n  useEffect(() => {\n    if (countRef.current && countRef2.current && loaderRef.current) {\n      const transformAmount = getSectionHeight(countRef.current);\n\n      const sequence1 = new Array(3).fill(\"\").flatMap((_, index) => [\n        [countRef.current, { y: `-${transformAmount * (index + 1)}px` }],\n        [\n          countRef2.current,\n          { y: `-${transformAmount * (index + 1)}px` },\n          { at: \"-1.8\" },\n        ],\n      ]) as TimelineDefinition;\n\n      timeline(sequence1, {\n        defaultOptions: { easing: [0.77, 0, 0.175, 1], duration: 2 },\n      });\n    }\n  }, []);\n\n  useEffect(() => {\n    const sequence2: TimelineDefinition = [\n      [titleRef.current, { y: 100 }],\n      [imageRef.current, { scale: 1.2 }, { at: \"<\" }],\n      [countRef.current, { opacity: 0 }, { at: \"<\" }],\n      [countRef2.current, { opacity: 0 }, { at: \"<\" }],\n      [loaderRef.current, { y: \"-100vh\" }, { at: \"-0.5\" }],\n      [titleRef.current, { y: 0 }, { at: \"-.5\" }],\n      [imageRef.current, { scale: 1 }, { at: \"<\" }],\n    ] as TimelineDefinition;\n\n    timeline(sequence2, {\n      defaultOptions: { easing: [0.77, 0, 0.175, 1], duration: 1, delay: 7 },\n    });\n  }, []);\n\n  return (\n\t\t<>\n\t\t\t<div className='loader-container' ref={loaderRef}>\n\t\t\t\t<div className='counter-container'>\n\t\t\t\t\t<ul className='counter-list' ref={countRef}>\n\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t<h3>2</h3>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t<h3>4</h3>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t<h3>6</h3>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t<h3>9</h3>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t</ul>\n\t\t\t\t</div>\n\n\t\t\t\t<div className='counter-container'>\n\t\t\t\t\t<ul className='counter-list' ref={countRef2}>\n\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t<h3>3</h3>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t<h3>9</h3>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t<h3>8</h3>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t<h3>9</h3>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t</ul>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div\n\t\t\t\tclassName='main-container'\n\t\t\t\tid='main-container'\n\t\t\t\tdata-scroll-container\n\t\t\t\tref={scrollRef}>\n\t\t\t\t<div className='hero-container'>\n\t\t\t\t\t<div data-scroll data-scroll-speed='-8' className='hero-image'>\n\t\t\t\t\t\t<img\n\t\t\t\t\t\t\tclassName='grid-item-media'\n\t\t\t\t\t\t\tref={imageRef}\n\t\t\t\t\t\t\tsrc='https://images.unsplash.com/photo-1454789415558-bdda08f4eabb?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2958&q=80'\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div data-scroll data-scroll-speed='-5' className='hero-title'>\n\t\t\t\t\t\t<h1 ref={titleRef}>Just A Cactus</h1>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t<div className='intro-container' data-scroll data-scroll-speed='0'>\n\t\t\t\t\t<p>\n\t\t\t\t\t\tCacti have interesting shapes and beautiful flowers. They thrive on\n\t\t\t\t\t\tneglect and come in nearly endless varieties. Ranging in size from a\n\t\t\t\t\t\tfew inches to several feet, cacti can be used as massed plantings,\n\t\t\t\t\t\tbackgrounds or accents. Many species grow well in containers and\n\t\t\t\t\t\tmake attractive, unusual houseplants. Once established, theres\n\t\t\t\t\t\tlittle to do but sit back and enjoy them.\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</>\n\t);\n}\n","import { useEffect, useRef } from \"react\";\nimport LocomotiveScroll, {\n  LocomotiveScrollOptions,\n  Scroll,\n} from \"locomotive-scroll\";\nimport \"locomotive-scroll/src/locomotive-scroll.scss\";\n\ntype UseLocomotiveScrollHook = [React.RefObject<Scroll>];\n\ntype Props = {\n  ref: React.RefObject<Element>;\n} & Omit<LocomotiveScrollOptions, \"el\">;\nconst useLocomotiveScroll = ({\n  ref,\n  ...otherProps\n}: Props): UseLocomotiveScrollHook => {\n  const locomotiveScrollRef = useRef<Scroll | null>(null);\n\n  useEffect(() => {\n    if (ref?.current) {\n      locomotiveScrollRef.current = new LocomotiveScroll({\n        ...otherProps,\n        el: ref.current,\n      });\n    }\n    return () => {\n      locomotiveScrollRef.current?.destroy();\n    };\n  }, [ref]);\n  return [locomotiveScrollRef];\n};\nexport default useLocomotiveScroll;\n","var warning = function () { };\r\nvar invariant = function () { };\r\nif (process.env.NODE_ENV !== 'production') {\r\n    warning = function (check, message) {\r\n        if (!check && typeof console !== 'undefined') {\r\n            console.warn(message);\r\n        }\r\n    };\r\n    invariant = function (check, message) {\r\n        if (!check) {\r\n            throw new Error(message);\r\n        }\r\n    };\r\n}\n\nexport { invariant, warning };\n","/*!\n * imagesLoaded v5.0.0\n * JavaScript is all like \"You images are done yet or what?\"\n * MIT License\n */\n\n( function( window, factory ) {\n  // universal module definition\n  if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory( window, require('ev-emitter') );\n  } else {\n    // browser global\n    window.imagesLoaded = factory( window, window.EvEmitter );\n  }\n\n} )( typeof window !== 'undefined' ? window : this,\n    function factory( window, EvEmitter ) {\n\nlet $ = window.jQuery;\nlet console = window.console;\n\n// -------------------------- helpers -------------------------- //\n\n// turn element or nodeList into an array\nfunction makeArray( obj ) {\n  // use object if already an array\n  if ( Array.isArray( obj ) ) return obj;\n\n  let isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';\n  // convert nodeList to array\n  if ( isArrayLike ) return [ ...obj ];\n\n  // array of single index\n  return [ obj ];\n}\n\n// -------------------------- imagesLoaded -------------------------- //\n\n/**\n * @param {[Array, Element, NodeList, String]} elem\n * @param {[Object, Function]} options - if function, use as callback\n * @param {Function} onAlways - callback function\n * @returns {ImagesLoaded}\n */\nfunction ImagesLoaded( elem, options, onAlways ) {\n  // coerce ImagesLoaded() without new, to be new ImagesLoaded()\n  if ( !( this instanceof ImagesLoaded ) ) {\n    return new ImagesLoaded( elem, options, onAlways );\n  }\n  // use elem as selector string\n  let queryElem = elem;\n  if ( typeof elem == 'string' ) {\n    queryElem = document.querySelectorAll( elem );\n  }\n  // bail if bad element\n  if ( !queryElem ) {\n    console.error(`Bad element for imagesLoaded ${queryElem || elem}`);\n    return;\n  }\n\n  this.elements = makeArray( queryElem );\n  this.options = {};\n  // shift arguments if no options set\n  if ( typeof options == 'function' ) {\n    onAlways = options;\n  } else {\n    Object.assign( this.options, options );\n  }\n\n  if ( onAlways ) this.on( 'always', onAlways );\n\n  this.getImages();\n  // add jQuery Deferred object\n  if ( $ ) this.jqDeferred = new $.Deferred();\n\n  // HACK check async to allow time to bind listeners\n  setTimeout( this.check.bind( this ) );\n}\n\nImagesLoaded.prototype = Object.create( EvEmitter.prototype );\n\nImagesLoaded.prototype.getImages = function() {\n  this.images = [];\n\n  // filter & find items if we have an item selector\n  this.elements.forEach( this.addElementImages, this );\n};\n\nconst elementNodeTypes = [ 1, 9, 11 ];\n\n/**\n * @param {Node} elem\n */\nImagesLoaded.prototype.addElementImages = function( elem ) {\n  // filter siblings\n  if ( elem.nodeName === 'IMG' ) {\n    this.addImage( elem );\n  }\n  // get background image on element\n  if ( this.options.background === true ) {\n    this.addElementBackgroundImages( elem );\n  }\n\n  // find children\n  // no non-element nodes, #143\n  let { nodeType } = elem;\n  if ( !nodeType || !elementNodeTypes.includes( nodeType ) ) return;\n\n  let childImgs = elem.querySelectorAll('img');\n  // concat childElems to filterFound array\n  for ( let img of childImgs ) {\n    this.addImage( img );\n  }\n\n  // get child background images\n  if ( typeof this.options.background == 'string' ) {\n    let children = elem.querySelectorAll( this.options.background );\n    for ( let child of children ) {\n      this.addElementBackgroundImages( child );\n    }\n  }\n};\n\nconst reURL = /url\\((['\"])?(.*?)\\1\\)/gi;\n\nImagesLoaded.prototype.addElementBackgroundImages = function( elem ) {\n  let style = getComputedStyle( elem );\n  // Firefox returns null if in a hidden iframe https://bugzil.la/548397\n  if ( !style ) return;\n\n  // get url inside url(\"...\")\n  let matches = reURL.exec( style.backgroundImage );\n  while ( matches !== null ) {\n    let url = matches && matches[2];\n    if ( url ) {\n      this.addBackground( url, elem );\n    }\n    matches = reURL.exec( style.backgroundImage );\n  }\n};\n\n/**\n * @param {Image} img\n */\nImagesLoaded.prototype.addImage = function( img ) {\n  let loadingImage = new LoadingImage( img );\n  this.images.push( loadingImage );\n};\n\nImagesLoaded.prototype.addBackground = function( url, elem ) {\n  let background = new Background( url, elem );\n  this.images.push( background );\n};\n\nImagesLoaded.prototype.check = function() {\n  this.progressedCount = 0;\n  this.hasAnyBroken = false;\n  // complete if no images\n  if ( !this.images.length ) {\n    this.complete();\n    return;\n  }\n\n  /* eslint-disable-next-line func-style */\n  let onProgress = ( image, elem, message ) => {\n    // HACK - Chrome triggers event before object properties have changed. #83\n    setTimeout( () => {\n      this.progress( image, elem, message );\n    } );\n  };\n\n  this.images.forEach( function( loadingImage ) {\n    loadingImage.once( 'progress', onProgress );\n    loadingImage.check();\n  } );\n};\n\nImagesLoaded.prototype.progress = function( image, elem, message ) {\n  this.progressedCount++;\n  this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;\n  // progress event\n  this.emitEvent( 'progress', [ this, image, elem ] );\n  if ( this.jqDeferred && this.jqDeferred.notify ) {\n    this.jqDeferred.notify( this, image );\n  }\n  // check if completed\n  if ( this.progressedCount === this.images.length ) {\n    this.complete();\n  }\n\n  if ( this.options.debug && console ) {\n    console.log( `progress: ${message}`, image, elem );\n  }\n};\n\nImagesLoaded.prototype.complete = function() {\n  let eventName = this.hasAnyBroken ? 'fail' : 'done';\n  this.isComplete = true;\n  this.emitEvent( eventName, [ this ] );\n  this.emitEvent( 'always', [ this ] );\n  if ( this.jqDeferred ) {\n    let jqMethod = this.hasAnyBroken ? 'reject' : 'resolve';\n    this.jqDeferred[ jqMethod ]( this );\n  }\n};\n\n// --------------------------  -------------------------- //\n\nfunction LoadingImage( img ) {\n  this.img = img;\n}\n\nLoadingImage.prototype = Object.create( EvEmitter.prototype );\n\nLoadingImage.prototype.check = function() {\n  // If complete is true and browser supports natural sizes,\n  // try to check for image status manually.\n  let isComplete = this.getIsImageComplete();\n  if ( isComplete ) {\n    // report based on naturalWidth\n    this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );\n    return;\n  }\n\n  // If none of the checks above matched, simulate loading on detached element.\n  this.proxyImage = new Image();\n  // add crossOrigin attribute. #204\n  if ( this.img.crossOrigin ) {\n    this.proxyImage.crossOrigin = this.img.crossOrigin;\n  }\n  this.proxyImage.addEventListener( 'load', this );\n  this.proxyImage.addEventListener( 'error', this );\n  // bind to image as well for Firefox. #191\n  this.img.addEventListener( 'load', this );\n  this.img.addEventListener( 'error', this );\n  this.proxyImage.src = this.img.currentSrc || this.img.src;\n};\n\nLoadingImage.prototype.getIsImageComplete = function() {\n  // check for non-zero, non-undefined naturalWidth\n  // fixes Safari+InfiniteScroll+Masonry bug infinite-scroll#671\n  return this.img.complete && this.img.naturalWidth;\n};\n\nLoadingImage.prototype.confirm = function( isLoaded, message ) {\n  this.isLoaded = isLoaded;\n  let { parentNode } = this.img;\n  // emit progress with parent <picture> or self <img>\n  let elem = parentNode.nodeName === 'PICTURE' ? parentNode : this.img;\n  this.emitEvent( 'progress', [ this, elem, message ] );\n};\n\n// ----- events ----- //\n\n// trigger specified handler for event type\nLoadingImage.prototype.handleEvent = function( event ) {\n  let method = 'on' + event.type;\n  if ( this[ method ] ) {\n    this[ method ]( event );\n  }\n};\n\nLoadingImage.prototype.onload = function() {\n  this.confirm( true, 'onload' );\n  this.unbindEvents();\n};\n\nLoadingImage.prototype.onerror = function() {\n  this.confirm( false, 'onerror' );\n  this.unbindEvents();\n};\n\nLoadingImage.prototype.unbindEvents = function() {\n  this.proxyImage.removeEventListener( 'load', this );\n  this.proxyImage.removeEventListener( 'error', this );\n  this.img.removeEventListener( 'load', this );\n  this.img.removeEventListener( 'error', this );\n};\n\n// -------------------------- Background -------------------------- //\n\nfunction Background( url, element ) {\n  this.url = url;\n  this.element = element;\n  this.img = new Image();\n}\n\n// inherit LoadingImage prototype\nBackground.prototype = Object.create( LoadingImage.prototype );\n\nBackground.prototype.check = function() {\n  this.img.addEventListener( 'load', this );\n  this.img.addEventListener( 'error', this );\n  this.img.src = this.url;\n  // check if image is already complete\n  let isComplete = this.getIsImageComplete();\n  if ( isComplete ) {\n    this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );\n    this.unbindEvents();\n  }\n};\n\nBackground.prototype.unbindEvents = function() {\n  this.img.removeEventListener( 'load', this );\n  this.img.removeEventListener( 'error', this );\n};\n\nBackground.prototype.confirm = function( isLoaded, message ) {\n  this.isLoaded = isLoaded;\n  this.emitEvent( 'progress', [ this, this.element, message ] );\n};\n\n// -------------------------- jQuery -------------------------- //\n\nImagesLoaded.makeJQueryPlugin = function( jQuery ) {\n  jQuery = jQuery || window.jQuery;\n  if ( !jQuery ) return;\n\n  // set local variable\n  $ = jQuery;\n  // $().imagesLoaded()\n  $.fn.imagesLoaded = function( options, onAlways ) {\n    let instance = new ImagesLoaded( this, options, onAlways );\n    return instance.jqDeferred.promise( $( this ) );\n  };\n};\n// try making plugin\nImagesLoaded.makeJQueryPlugin();\n\n// --------------------------  -------------------------- //\n\nreturn ImagesLoaded;\n\n} );\n","","","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n"],"names":["preloadImages","selector","resolve","imagesLoaded","document","background","height","element","childElementCount","scrollRef","useRef","countRef","countRef2","loaderRef","titleRef","imageRef","useLocomotiveScroll","ref","smooth","smoothMobile","useEffect","Promise","locomotiveRef","transformAmount","getSectionHeight","sequence1","y","index","at","timeline","defaultOptions","easing","duration","sequence2","scale","opacity","delay","otherProps","locomotiveScrollRef","el","current"],"sourceRoot":""}